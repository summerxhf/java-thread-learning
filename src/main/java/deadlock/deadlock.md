（十五）java并发编程--线程的死锁以及解决方案(生产者消费者)

1、什么是死锁？

线程在操作系统使用不同的资源,一般以以下方式使用这些资源。
1）请求一个资源。
2）使用这个资源。
3）释放资源。

死锁的情况是，一些线程被阻塞，每个线程都拥有一个资源，并且等待另外一个进程以获取另外的一个资源。
想了想类似于生活中的哪些情形，我拥有有一本书（资源使用）叫做《java并发编程》 ，你拥有一本叫《java虚拟机》，我需要你的才能把java理解的更好，你也需要
我的书，我们都各自拥有一本，但都需要得到对方的书籍而完成某个“学习线程”，我等待着你使用完你的书籍，你也等待着我使用完我的本书，便互相等待了。
形成了死锁。（互相等待对方的资源，形成死循环，也许例子不太恰当。）
相同的情形在操作系统中，当两个或者多个线程拥有一些资源，并且等待其他下线程拥有的资源。
例如如下图所示，线程1拥有资源1并且等待被线程2拥有的资源2， 而线程2拥有资源2但是，等待被线程1拥有的资源。

出现死锁的四个条件：
互斥：
线程的共享资源，为了线程安全可能需要同步（例如synchronized），也就是同一时刻只能有一个线程使用这个资源。
在某一个时刻这个资源只能被一个线程使用。
拥有锁和等待：
一个线程至少拥有一个资源，并且等待其他资源。
不能强占资源：一个线程不能获取一个资源，除非另外一个线程释放这个资源。
循环等待：
一些线程互相等待对方释放资源，形成死循环。


2、解决死锁的办法？

