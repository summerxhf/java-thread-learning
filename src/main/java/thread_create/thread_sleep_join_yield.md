(十四)线程的阻塞

java中我们可以使用线程类的三种方式来阻止线程的执行。
# 1、yield（）
yield英文的意思是屈服，如同其意，会让另一个线程屈服。
yield()方法可以暂停当前执行的线程,以便为相同优先级的其他等待线程提供机会, 如果没有等待线程, 或者等待线程的
优先级较低, 那么相同的线程将会执行。当获得执行机会，产生的线程，由线程的调度程序决定的。

# 2、join（）
任何执行的程序在线程t1上调用t2.join（）方法，则t1将进入等待状态，直到t2执行完成t1则继续执行。
# 3、sleep（）
根据我们的要求，可以让线程在指定的时间段内处于睡眠状态。

# 4、wait（）

wait()方法一般和notify()、notifyAll（）方法使用，这三个方法用于协调多线程对共享数据的存取，所以必须在synchronized块内使用，
也就是说，wait（）、notify、notifyAll（）的任务在调用这些方法前必须拥有对象的锁。
他们是Object的方法，并不是Thread类的方法。

为什么wait（）、notify（）、notifyAll（）没有在Thread中？
因为都是锁级别的操作，锁属于对象，所以把他们定义到Object中，任何一个对象都可能获得一把锁。



//todo把interrupt 添加上interrupted 博客完整.
//加上本篇的例子.
//写死锁的博客,以及生产者和消费者模式.

//继续current包中的对象,继续信号量等.


